\chapter{Basic Operations} \label{chap:operations}

The basic types have been introduced in the previous chapter, so we move on with the description of the basic BLAS operations.

\section{Vector-Vector Operations (BLAS Level 1)}

{\ViennaCL} provides all vector-vector operations defined at level 1 of BLAS. Tab.~\ref{tab:blas-level-1} shows how these operations can be carried
out in \ViennaCL. The function interface is compatible with {\ublas},
thus allowing quick code migration for {\ublas} users.


\TIP{For full details on level 1 functions, refer to the reference documentation
located in \texttt{doc/doxygen/}}


\begin{table}[tb]
\begin{center}
\begin{tabular}{l|l|p{6cm}}
Verbal & Mathematics & ViennaCL\\
\hline
swap    & $x \leftrightarrow y$ & \texttt{swap(x,y);} \\
stretch    & $x \leftarrow \alpha x$ & \texttt{x *= alpha;} \\
assignment & $y \leftarrow x$ & \texttt{y = x;} \\
multiply add & $y \leftarrow \alpha x + y$ & \texttt{y += alpha * x;} \\
multiply subtract & $y \leftarrow \alpha x - y$ & \texttt{y -= alpha * x;} \\
inner dot product & $\alpha \leftarrow x^{\mathrm{T}} y$ & \texttt{inner\_prod(x,y);} \\
$L^1$ norm & $\alpha \leftarrow \Vert x \Vert_1$ & \texttt{alpha = norm\_1(x);} \\
$L^2$ norm & $\alpha \leftarrow \Vert x \Vert_2$ & \texttt{alpha = norm\_2(x);} \\
$L^\infty$ norm & $\alpha \leftarrow \Vert x \Vert_\infty$ & \texttt{alpha = norm\_inf(x);} \\
$L^\infty$ norm index& $i \leftarrow \max_i \vert x_i \vert$ & \texttt{i = index\_norm\_inf(x);} \\
plane rotation & $(x,y) \leftarrow (\alpha x + \beta y, -\beta x + \alpha y)$ &
\texttt{plane\_rotation(alpha, beta, x, y);} \\
\end{tabular}
\caption{BLAS level 1 routines mapped to {\ViennaCL}. Note that the free functions reside in namespace \texttt{viennacl::linalg}}
\label{tab:blas-level-1}
\end{center}
\end{table}
 
\section{Matrix-Vector Operations (BLAS Level 2)}
The interface for level 2 BLAS functions in {\ViennaCL} is similar to that of
{\ublas} and shown in Tab.~\ref{tab:blas-level-2}.

\TIP{For full details on level 2 functions, refer to the reference documentation
located in \texttt{doc/doxygen/}}


\begin{table}[tb]
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{p{4cm}|l|p{7cm}}
Verbal & Mathematics & ViennaCL\\
\hline
matrix vector product & $y \leftarrow A x$ & \texttt{y = prod(A, x);} \\
matrix vector product & $y \leftarrow A^\mathrm{T} x$ & \texttt{y = prod(trans(A), x);} \\
inplace mv product & $x \leftarrow A x$ & \texttt{x = prod(A, x);} \\
inplace mv product & $x \leftarrow A^\mathrm{T} x$ & \texttt{x = prod(trans(A), x);} \\
\hline
scaled product add & $y \leftarrow \alpha A x + \beta y$ & \texttt{y = alpha * prod(A, x) + beta * y} \\
scaled product add & $y \leftarrow \alpha A^{\mathrm T} x + \beta y$ & \texttt{y = alpha * prod(trans(A), x) + beta * y} \\
\hline
tri. matrix solve & $y \leftarrow A^{-1} x$ & \texttt{y = solve(A, x, tag);} \\
tri. matrix solve & $y \leftarrow A^\mathrm{T^{-1}} x$ & \texttt{y = solve(trans(A), x, tag);} \\
inplace solve & $x \leftarrow A^{-1} x$ & \texttt{inplace\_solve(A, x, tag);} \\
inplace solve & $x \leftarrow A^\mathrm{T^{-1}} x$ & \texttt{inplace\_solve(trans(A), x, tag);} \\
\hline
rank 1 update & $A \leftarrow \alpha x y^{\mathrm T} + A$ & \texttt{A += alpha * outer\_prod(x,y);} \\
symm. rank 1 update & $A \leftarrow \alpha x x^{\mathrm T} + A$ & \texttt{A += alpha * outer\_prod(x,x);} \\
rank 2 update & $A \leftarrow \alpha (x y^{\mathrm T} + y x^{\mathrm T}) + A$ & \texttt{A += alpha * outer\_prod(x,y); A += alpha * outer\_prod(y,x);} \\
\end{tabular}
\caption{BLAS level 2 routines mapped to \ViennaCL. Note that the free functions reside in namespace \texttt{viennacl::linalg}}
\label{tab:blas-level-2}
\end{center}
\end{table}

\section{Matrix-Matrix Operations (BLAS Level 3)}
Full BLAS level 3 support is since {\ViennaCL} 1.1.0, cf.~Tab.~\ref{tab:blas-level-3}. While BLAS
levels 1 and 2 are mostly memory-bandwidth-limited, BLAS level 3 is mostly
limited by the available computational power of the respective device. Hence,
matrix-matrix products regularly show impressive performance gains on mid-
to high-end GPUs when compared to a single CPU core.

Again, the {\ViennaCL} API is identical to that of {\ublas} and comparisons can
be carried out immediately, as is shown in the tutorial located in
\texttt{examples/tutorial/blas3.cpp}.

As for performance, {\ViennaCL} yields decent performance gains at BLAS level
3 on mid- to high-end GPUs compared to CPU implementations using a single core
only. Nevertheless, one must not expect to obtain the reported peak performance
of hundreds of GFLOPs for the multiplication of arbitrary matrices. These rates
can typically only obtained when tailoring the compute kernel(s) to a
particular device and certain matrix dimensions, while {\ViennaCL} provides
kernels that represent a good compromise between efficiency and portability
among a large number of different devices and device types.

\begin{table}[tb]
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{p{4cm}|l|p{7.5cm}}
Verbal & Mathematics & ViennaCL\\
\hline
matrix-matrix product & $C \leftarrow A \times B$ & \texttt{C = prod(A, B);}
\\
matrix-matrix product & $C \leftarrow A \times B^\mathrm{T}$ & \texttt{C =
prod(A, trans(B));} \\
matrix-matrix product & $C \leftarrow A^\mathrm{T} \times B$ & \texttt{C =
prod(trans(A), B);} \\
matrix-matrix product & $C \leftarrow A^\mathrm{T} \times B^\mathrm{T}$ &
\texttt{C = prod(trans(A), trans(B));} \\
\hline
tri. matrix solve & $C \leftarrow A^{-1} B$ & \texttt{C = solve(A, B, tag);}
\\
tri. matrix solve & $C \leftarrow A^\mathrm{T^{-1}} B$ & \texttt{C =
solve(trans(A), B, tag);} \\
tri. matrix solve & $C \leftarrow A^{-1} B^\mathrm{T}$ & \texttt{C = solve(A,
trans(B), tag);} \\
tri. matrix solve & $C \leftarrow A^\mathrm{T^{-1}} B^\mathrm{T}$ & \texttt{C
= solve(trans(A), trans(B), tag);} \\
%
inplace solve & $B \leftarrow A^{-1} B$ & \texttt{inplace\_solve(A, trans(B),
tag);} \\
inplace solve & $B \leftarrow A^\mathrm{T^{-1}} B$ &
\texttt{inplace\_solve(trans(A), x, tag);} \\
inplace solve & $B \leftarrow A^{-1} B^\mathrm{T}$ & \texttt{inplace\_solve(A,
trans(B), tag);} \\
inplace solve & $B \leftarrow A^\mathrm{T^{-1}} B^\mathrm{T}$ &
\texttt{inplace\_solve(trans(A), x, tag);} \\
\end{tabular}
\caption{BLAS level 3 routines mapped to \ViennaCL. Note that the free functions
reside in namespace \texttt{viennacl::linalg}}
\label{tab:blas-level-3}
\end{center}
\end{table}

